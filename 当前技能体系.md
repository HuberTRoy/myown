当前的技能体系：

1. 前端。

    已知：
    1. 原生Js方向原型的方面的了解是比较笼统的阶段，说他笼统主要是没有具体的实践。Js是基于原型链的继承模型。
    2. CSS方向，CSS基本体系还算可以，薄弱项：动画，svg。
    3. canvas与svg是一个绝对的弱项，但略懂一点= =。
    4. 框架方面主要技术栈是Vue，React。
    5. HTTP方向上状态码，2的多路复用(仅了解)，TCP协议3/4握手状态，阻塞窗口(比较模糊)，分布式的JWT。
    6. 缓存策略，cache-control。
    7. 性能调优上，缓存(CDN)，懒加载(分块，动态加载异步组件)，减少体积，提取公共部分，web worker，延迟加载(只加载必要的部分)。
    8. webpack打包了解，entry，output，loader，plugins。loader与plugins没有写过自定义插件阶段在用，调优上optimiztion，splitChunk，tree-shaking(usedExport)。
        关于tree-shaking的一些更进一步的理解：
            对于webpack4来说，tree-shaking默认开启，因为tree-shaking是基于es6的静态导入，所以需要配置Babel转译时不要编译成非ES6模式的导入了。
            tree-shaking很好理解就是剔除无用代码，但关键点在于这个看似无用的代码是不是真的无用，所以webpack要求给出这些文件是否含有副作用，一个易于理解的副作用例子是：
            如果写了一个类，并把它注册成事件的回调，那么将会调用它的handleEvent方法，但并没有显式的调用它，比如better-scroll里所注册的事件，不过好像webpack并未做对类的shaking。
            
            ```javascript
            class Scroll {
                handleEvent() {
                    console.log('You called me.')
                }
            }

            window.addEventListener('visibilitychange', new Scroll())
            ```

    9. Node端的脚手架(不了解，需要了解)。
    10. Ts是方面React小小的尝试了一下Ts -> 主要就是T，配合React做了一个完整的上线项目，挺小不过五脏俱全：

        1. d.ts用来声明某些内容所含的内容，比如微信会嵌入一个WxJs，这时候就可以(必须)做一个类型的声明。
        2. 基础的接口啥的可以直接查文档，interface，变量，函数的类型声明等。

    11. 小程序写过项目。
    12. 适配方面vw适配方案感觉是很棒的，rem次之。
    13. 浏览器方面：Js事件循环一次task伴随多次microTask，主要应用 -> Vue中的nextTick(目前是一个microTask，在某个task执行之后会将当前所有的microTask执行，不然的话会排到task尾，一个例子是UI更新，这个会在微任务执行之后进行更新，如果nextTick是一个task那如果nextTick中的代码影响了UI更新总是会使其在这之后eg: `<div :style={ absolute, top: currentTop }></div>...scrollEventHandler() { this.$nextTick(() => { this.currentTop = clientTopHeight }) }` 作用就是此元素始终保持在顶部(不要说为什么不用fixed)如果此时是一个task那么在滚动之后$nextTick注册的会在UI更新之后在执行，出现的视觉效果就是抖动，top的变化是 0 -> UI更新 -> 10px -> UI更新，那么如果是microTask，执行的则是 0 -> 10px -> UI更新，microtask一般有Promise.then,catch,finally，    mutationObserver。
        13.1 浏览器机制：冒泡/捕获 -> 冒泡是从触发的元素向上冒泡，捕获则是从外层向内传播。
        ```javascript
        <body>
            <div>
                1
            </div>
        </body>
        ```

        冒泡 -> div -> body。
        捕获 body -> div。

        跨域：这个主要在后端，放在后端讲，在这里提及主要是因为是这个限制是浏览器做的限制，解决方法由后端完成。

        存储：cookies/localStore/sessionStore/indexedDB(没用过)

        开发工具：performance/layers/Js Profilters/memery简单内存泄漏的修正。

        预加载/异步script（调优用）

        浏览器渲染：解析HTML -> 解析CSS 
                     ↓          ↓           -> 合并 -> 生成渲染树 -> 绘制 -> 显示。
                   生成DOM树   生成CSSDOM树

        遇到script时会暂停DOM树的生成，直到脚本完成。
        重绘与回流 重绘的发生是局部的，不影响整体会把部分重新渲染。
        回流通常是整体的，元素的大小布局等改变。
        重绘与回流不可避免但相对的不要频繁的触发他们，调试工具 chrome -> more tools -> render。

    14. Js方面：核心注意点：变量范围，闭包作用域，this指向，事件循环，Promise，ES6的分包，import/export，new，继承。
    15. 部署方面，drone/Jenkins。
    16. 代码检查Eslint。
    17. 服务器端渲染(Nuxt)。
    18. 一些安全方面的知识。
    19. JS方面冒泡与捕获上的深入，由一个需求说起，为页面上非常多的可点击按钮增加一些额外的效果，使得在点击后先进行一些检查。
        1. 直接做的话是去已经绑定的点击事件中逐一添加这个检查函数，这样做的好处是直接去读绑定的事件即可知道所有的内容比较直观，符合第一印象，坏处是如果需要添加的内容非常多，那写起来非常麻烦并且如果后续要删除掉会很难受。
        2. 另一种方法是如果这些点击事件都进行了API的交互，那么可以在API请求前设置拦截器拦截对应的请求并作出相应的响应，这样的好处是代码统一管理，坏处是并不直观(考虑增加一些log)。
        3. 第三种方法目前只证实了可行并未实际使用，收集所有需要点击的按钮的class或id，需要唯一，至少页面内唯一，然后为其注册一个捕获事件，验证后发出一个自定义的同样事件重新冒泡。
            这样做的好处与2.一致，坏处很明显，并不直观且容易造成BUG，因为class并不唯一。
            当然实现方式上，如果结合Vue也可以用自定义指令配合1.来实现。

    20. 

    需扩展：
    1. Ts深入一点(高)。
    2. React深入一点(高)。
    3. Vue源码方向(高，当前目标)。
    4. 多端(低)。
    5. 微前端(中)。
    6. canvas，svg(低看情况)。
    7. Node(中)。
    8. 调优手段实践+体系构建(高)。
    9. 部署(低，已实践过需扩展下广度)。
    10. 设计模式架构层(高)。
    11. 监控上报体系(高，当前目标)。

    不了解：
    1. 测试体系。
    2. SEO。
    3. 可视化组件构建。

2. 后端。
    Python。
    抓包工具，burp，wrishark。
    Nginx（能说一说配一配）。
    DNS(能扯一扯)。
    网络层(能扯一扯需要补)。
    数据库(查文档水平mysql用过)。
    缓存(Redis查文档水平用过)。
    跨域在这里说一下：需要返回一些HTTP头信息让浏览器确认这个域名可以跨域。具体可以在后端程序处或者Nginx处做处理。

3. 软技能。

    英语，还行，看文档没啥压力，听/写有点弱。
    口琴，有点差，凑合。

4. 优。

    Github不错有几个星星多的项目，学习能力不错。

5. 劣。

    学历没有，人脉不足，上限可能会低。

6. 算法。
    排序：归并(分治)，快排(分治)，冒泡，选择。
    二叉树 -> 二叉排序树 -> 2-3(之前略懂，现在忘了) -> 红黑(不懂)
    动态规划(解决子问题)。
    回溯。
    BFS/DFS。
    图。
    最短路径(忘了)。
    堆。
    栈。
    队列。

    很久了，前端的业务方向接触的算法不多。


7. Git。

    版本控制。
    add commit push pull log checkout branch merge reset submodule。
