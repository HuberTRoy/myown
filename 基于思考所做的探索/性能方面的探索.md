最近在做一些基础的优化，总结一下思考的点：

项目主要面向Vue：


Vue代码层面的性能优化：

1. 首屏 main.js 的内容挂载优化，插件库尽量按需加载。
2. 无用/不必首屏的挂载尽量放在后面。
3. router处的懒加载。
4. 组件内的异步组件和router其实是一个思路。
5. 减少接口请求，比如列表内删除，新增，这些尽可能不通过重新请求或者尽可能少的重新请求。
6. ws下内容过多导致的dom特别多的优化 -> 参考无限滚动的列表，只展示视觉范围内的dom，或者按斗鱼这些直播平台的弹幕列表里的只显示固定数量的dom。
7. 缓存，代码层面的缓存可以有keep-alive，也可以有特定接口的缓存，如keep-alive相对于一个组件而言，但一个组件内可能会请求很多接口，有些接口没有那么大的变动频率，比如已登录用户的信息，可以自写一个缓存系统(LRU等)。
8. 重绘回流下的优化，这些还没有遇到过。
    遇到一个object-fit: cover的性能问题：object-fit；cover会使得图片适应当前区域，如果这个图片的原像素与当前区域差别过大，那么在进行滚动后的重绘时会极大的消耗性能，造成FPS的下降。
    translateZ(0)创建图层进行图层上的绘制然后交由浏览器合成。

9. 大数据的优化，前端业务端对于算法的需求相对较小，在普通业务方面性能并不是一个需要关注的点，可能需要注意的大数据点是canvas绘制方面的动画window.requestAnimateFrame，按帧率刷新。

HTTP方面的性能优化:

1. 首当其冲的是缓存和CDN，
    缓存这里说一下一般通过HTTP头中的Cache-Control去定义：
        no-store 是没有缓存，完完全全每次都去服务器端拉数据  
        no-cache 比no-store稍弱，这个策略会去服务器端寻求验证，如果资源未过期那么就用缓存否则拉取最新的。  
        max-age max-age设置的是自请求发起时的秒数，在这个时间段内都会走缓存，相当于一种强缓存，在过期时间之前都不会向服务器发送任何请求 注意这里的不会 向服务器发送任何请求。  
        must-revalidate 这个策略和no-cache非常相似，与max-age配合使用，如果超过了max-age那么会去验证缓存文件的新鲜度。  
        last-modified或者etag去进行验证是否命中缓存，last-modified表示本地缓存文件的最后修改时间，如果和服务器端的同文件对起来那就使用缓存（如果本地打开过缓存文件但没有修改任何内容并保存那就会干掉缓存）etag则不根据文件的最后修改时间去算，至于根据什么算那需要去查一查，一般用即可，深究下去关键字：ETag算法，唯一，尽可能快速。  

2. HTTP/2多路复用。
3. GZIP。

Webpack打包方面的优化：

1. Tree-shaking。
2. 分块。
3. 压缩混淆。
4. 静态GZIP。


# 其他

在页面到达之前，Nginx(或其他的Apache等)做负载均衡，

数据库方面了解不多，关键字分库，分表，读写分离，主从，缓存。


最近在项目调优上的一些进展。

在核心To C产品上的优化，目的是提高用户打开目标页面的速度，技术栈是Nuxt，一开始的lighthouse给出的速率是10s左右，performance里从白屏到首次有画面出现的节点在1800-2000ms之间（从lighthoust给的内容track），单独performance的话一开始的时间已经忘记了没有记录。

目前一共做了两次优化，一次是针对服务器端渲染的配合下的优化，另一次则是一个比较通用的优化。

先说第一次，产品有一个核心页面，未优化前所有此页面内需要的组件会一次性加载出来。

这样其实并不合理，和动态路由一样，页面内也可以再做一层组件优化：

1. ssr渲染下动态组件配合client-only(nuxt)，可以做成优先加载某些组件延迟加载某些组件。比如核心功能是播放器，那就优先加载播放器，其他的内容全都是preload的客户端预加载，当内容返回到客户端，播放器已经有了，其他的内容慢慢加载出来。

2. 用if判断的内容也可以用动态组件。

3. preload预加载资源css/js，这里注意，css资源如果预加载，chrome下不要设置为crossorigin，chrome会设置crossorigin的验证模式为omit，如果与后端不符的话会导致加载两次。

4. 预加载DNS，预连接一些必连的内容。

5. defer，对于可以非阻塞加载的js可以用defer让他们变为非阻塞状态。

6. 缓存，这里着重说一下缓存，之前对缓存做了一个简单的概括，这次是一个很好的实践，源自于阿里的OSS缓存未生效。
    缓存上面说到由cache-control控制，这里注意的是如果没有cache-control并非没有缓存，第二次请求时会走协商缓存的路数，304。

    强缓存上面，一般CDN都会设置一个过期时间 cache-control: max-age=600，然后由age来判断文件的新鲜程度（或者其他last-modified，eTag），不新鲜之后会走协商的路数。

    强缓存是最快的，从内存或者硬盘里拉取，几乎0ms，之后是协商缓存，协商缓存稍微快一点。

做了上面的内容之后，加载速度Up，现在从回车地址栏到有页面出来只需要700ms左右(在测试服务器下的测试，记录此日志时线上的环境经过一次优化已经降到了900ms，不过lighthouse里FCP给的是7s左右，这次在测试环境下只有2s)，从完全的白屏到有loading大概有200ms，loading到有意义的页面出来大概是500ms。


7. 老生常谈的分块，这里专门做的一个优化还有将CSS分块，我们有很多主题，之前将所有的主题CSS一次性加载，但这并不必须却又不好分块，目前还未做，做了之后在记录。

