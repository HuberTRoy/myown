最近在做一些基础的优化，总结一下思考的点：

项目主要面向Vue：


Vue代码层面的性能优化：

1. 首屏 main.js 的内容挂载优化，插件库尽量按需加载。
2. 无用/不必首屏的挂载尽量放在后面。
3. router处的懒加载。
4. 组件内的异步组件和router其实是一个思路。
5. 减少接口请求，比如列表内删除，新增，这些尽可能不通过重新请求或者尽可能少的重新请求。
6. ws下内容过多导致的dom特别多的优化 -> 参考无限滚动的列表，只展示视觉范围内的dom，或者按斗鱼这些直播平台的弹幕列表里的只显示固定数量的dom。
7. 缓存，代码层面的缓存可以有keep-alive，也可以有特定接口的缓存，如keep-alive相对于一个组件而言，但一个组件内可能会请求很多接口，有些接口没有那么大的变动频率，比如已登录用户的信息，可以自写一个缓存系统(LRU等)。
8. 重绘回流下的优化，这些还没有遇到过。
9. 大数据的优化，前端业务端对于算法的需求相对较小，在普通业务方面性能并不是一个需要关注的点，可能需要注意的大数据点是canvas绘制方面的动画。

HTTP方面的性能优化:

1. 首当其冲的是缓存和CDN，
    缓存这里说一下一般通过HTTP头中的Cache-Control去定义：
        no-store 是没有缓存，完完全全每次都去服务器端拉数据  
        no-cache 比no-store稍弱，这个策略会去服务器端寻求验证，如果资源未过期那么就用缓存否则拉取最新的。  
        max-age max-age设置的是自请求发起时的秒数，在这个时间段内都会走缓存，相当于一种强缓存，在过期时间之前都不会向服务器发送任何请求 注意这里的不会 向服务器发送任何请求。  
        must-revalidate 这个策略和no-cache非常相似，与max-age配合使用，如果超过了max-age那么会去验证缓存文件的新鲜度。  
        last-modified或者etag去进行验证是否命中缓存，last-modified表示本地缓存文件的最后修改时间，如果和服务器端的同文件对起来那就使用缓存（如果本地打开过缓存文件但没有修改任何内容并保存那就会干掉缓存）etag则不根据文件的最后修改时间去算，至于根据什么算那需要去查一查，一般用即可，深究下去关键字：ETag算法，唯一，尽可能快速。  

2. HTTP/2多路复用。
3. GZIP。

Webpack打包方面的优化：

1. Tree-shaking。
2. 分块。
3. 压缩混淆。
4. 静态GZIP。

待补充...



